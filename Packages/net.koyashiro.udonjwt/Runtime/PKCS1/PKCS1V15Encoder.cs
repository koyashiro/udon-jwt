using System;
using Koyashiro.UdonJwt.Asn1;
using Koyashiro.UdonSHA2;

namespace Koyashiro.UdonJwt.PKCS1
{
    public static class PKCS1V15Encoder
    {
        public static byte[] Encode(byte[] message)
        {
            const int DIGEST_ALGORITHM_LENGTH = 15;
            const int DIGEST_LENGTH = SHA256.DIGEST_LENGTH + 2;
            const int DIGEST_INFO_LENGTH = DIGEST_ALGORITHM_LENGTH + DIGEST_LENGTH;
            const int LENGTH = 256;
            const int PADDING_LENGTH = LENGTH - 51;

            var digestAlgorithm = new byte[DIGEST_ALGORITHM_LENGTH] {
                // SEQUENCE
                (byte)Asn1TagKind.SequenceAndSequenceOf,
                // 11
                0x0d,
                // SHA-256
                0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
                // NULL
                0x05, 0x00
            };

            var padding = new byte[PADDING_LENGTH] {
                0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00
            };

            var buf = new byte[LENGTH];

            // Padding
            Array.Copy(padding, buf, PADDING_LENGTH);

            // Digest info
            buf[PADDING_LENGTH] = (byte)Asn1TagKind.SequenceAndSequenceOf;
            buf[PADDING_LENGTH + 1] = (byte)DIGEST_INFO_LENGTH;

            // Digest Algorithm
            Array.Copy(digestAlgorithm, 0, buf, PADDING_LENGTH + 2, DIGEST_ALGORITHM_LENGTH);

            // Digest
            buf[PADDING_LENGTH + DIGEST_ALGORITHM_LENGTH + 2] = (byte)Asn1TagKind.OctetString;
            buf[PADDING_LENGTH + DIGEST_ALGORITHM_LENGTH + 3] = SHA256.DIGEST_LENGTH;
            Array.Copy(SHA256.ComputeHash(message), 0, buf, PADDING_LENGTH + DIGEST_ALGORITHM_LENGTH + 4, SHA256.DIGEST_LENGTH);

            return buf;
        }
    }
}
